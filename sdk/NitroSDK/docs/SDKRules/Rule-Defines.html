<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=windows-1252">
<META name="GENERATOR" content="IBM WebSphere Studio Homepage Builder Version 7.0.0.0 for Windows">
<META http-equiv="Content-Style-Type" content="text/css">
<TITLE>Environmental variables when compiling SDK</TITLE>
<LINK rel="stylesheet" href="NitroSDKStandard.css" type="text/css">
</HEAD>
<BODY>
<H1>Build Switch</H1>
<H2><A name="SetenvForBuild">Environmental variables when building SDK</A></H2>
<P>The below table is a list of the environmental variables for changing the build conditions of the NitroSDK tree. Besides setting these values with normal environmental variables, it is possible to configure them by passing make NITRO_DEBUG=True as a make command argument or by describing NITRO_DEBUG=True in Makefile. When not configured, the initial value is used.</P>
<TABLE border="1" width="100%" cellspacing="0" cellpadding="2">
  <COL span="1" width="160">
  <TBODY>
    <TR>
<TH valign="top" align="left">CWFolder_NITRO<BR> or <BR> CWFOLDER_NITRO<BR>
      </TH>
<TD valign="top" align="left">CodeWarrior is installed in this directory. <BR>It is automatically configured when IS NITRO EMULATOR is installed.<BR>This directory must be delimited by single quotes as shown below when set using bash of cygwin. <BR>
<PRE><CODE>% export CWFolder_NITRO='D:/Program Files/Metrowerks/CodeWarrior' </CODE></PRE>
       <BR>This directory must be specified as shown below when set using a Windows environment variable. <BR>
<PRE><CODE>D:/Program Files/Metrowerks/CodeWarrior</CODE></PRE>
       Both / and \ will work as path delimiters. <BR>Initial value: C:/Program Files/Metrowerks/CW for NINTENDO DS V1.0.2</TD>
    </TR>
    <TR>
<TH valign="top" align="left">LM_LICENSE_FILE</TH>
<TD valign="top" align="left">License file path for CodeWarrior. <BR>Initial value: None Usually set when CodeWarrior is installed.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITROSDK_ROOT<BR> <FONT color="#ff0000"> Important</FONT></TH>
<TD valign="top" align="left">Directory in which NITRO-SDK is installed and $NitroSDK is deployed.<BR>Both / and \ can be used as path delimiters, but \ is recommended because \ is preferred in the IDE of CodeWarrior.<BR>The default value is C:\NitroSDK, but the path selected by the installer will be set when the SDK is provided by the installer.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_STD_PCHDR<BR>NITRO_NO_STD_PCHDR</TH>
<TD valign="top" align="left">When some value is set for NITRO_STD_PCHDR, the build system precompiles $NitroSDK/include/nitro.h before the build, and reads in the result during the build. Faster builds can be expected. If you want to temporarily suppress this compile, set a value for NITRO_NO_STD_PCHDR.<BR><FONT color="#ff0000">This feature is supported beginning with NITRO-SDK 3.0.</FONT></TD>
    </TR>
    <TR>
<TH align="left" valign="top">NITROSDK_LANG</TH>
<TD valign="top" align="left">You can switch the NitroSDK compile options between Japanese and English.<BR><BR> For the options, use <CODE>&quot;-enc ascii&quot;</CODE> for English and <CODE>&quot;-enc SJIS&quot;</CODE>.
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>en</TD>
<TD>English</TD>
          </TR>
          <TR>
<TD>jp</TD>
<TD>Japanese</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: Japanese</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_PROC<BR> <FONT color="#a0a0a0">No change necessary</FONT></TH>
<TD align="left">This switch switches between generating code for the main processor and the sub processor. <FONT color="#ff0000">Use the initial value as is.</FONT><BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>ARM9</TD>
<TD>Code for the Main Processor</TD>
          </TR>
          <TR>
<TD>ARM7</TD>
<TD>Code for the Sub Processor</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: ARM9 (Code for the Main Processor)</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_MAKEROM<BR> <FONT color="#a0a0a0">No change necessary</FONT></TH>
<TD align="left">If any value has been set for NITRO_MAKEROM, a ROM image of the program will be generated by the makerom.exe tool. Since this is always specified, there is no need to make an explicit setting.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_CODEGEN</TH>
<TD align="left">This gives the compiler and the assembler default values for whether to generate ARM code or Thumb code. If there is no explicit setting in the source, the compiler and assembler generate the code according to these values.<BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>ARM</TD>
<TD>32-bit ARM code</TD>
          </TR>
          <TR>
<TD>THUMB</TD>
<TD>16-bit THUMB code</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: ARM</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_PLATFORM<BR> and <BR> NITRO_TS_VERSION<BR> <FONT color="#999999">No change necessary</FONT></TH>
<TD valign="top" align="left">The NITRO compile target is specified as follows.<BR><FONT color="#ff0000">Use the initial value as is.</FONT><BR> <BR> Specify the architecture with the <B>NITRO_PLATFORM</B> value. For TS, <BR> specify the exact version with <B>NITRO_TS_VERSION</B>.<BR>
      <TABLE border="1" width="500">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TH colspan="2">Switching by NITRO_PLATFORM</TH>
          </TR>
          <TR>
<TD>TS</TD>
<TD>IS-NITRO-EMULATOR hardware as well as the retail version of the Nintendo DS system<BR> (Select the exact version with NITRO_TS_VERSION)</TD>
          </TR>
          <TR>
<TD>TEG</TD>
<TD>TEG board</TD>
          </TR>
          <TR>
<TD>BB</TD>
<TD>Breadboard</TD>
          </TR>
        </TBODY>
      </TABLE>
      <TABLE border="1" width="500">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TH colspan="2">Switching by NITRO_TS_VERSION</TH>
          </TR>
          <TR>
            <TD>0</TD>
<TD>From the TS Breadboard to IS-NITRO-EMULATOR hardware version C</TD>
          </TR>
          <TR>
            <TD>100</TD>
<TD>IS-NITRO-EMULATOR hardware version D</TD>
          </TR>
          <TR>
            <TD>200</TD>
<TD>IS-NITRO-EMULATOR hardware version E as well as the retail version of the Nintendo DS system (as of 09/10/2004)</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: NITRO_PLATFORM=TS as well as NITRO_TS_VERSION=200<BR> <BR> Note: In the NITRO-SDK, os and spi libraries are prepared for each TS_VERSION. This is relevant when the development environment uses the TS breadboard, etc. and has owner information in an old save format. But when the save format is the same as that used for the retail DS system, the library is exactly the same. When the make system is used, the library for linking is selected automatically based on the environment variable. But in a development environment using IDE, you need to manually select which library to link. Note, however, that selecting a library is meaningless except when a development environment that uses TS breadboard has been used, so there is no problem using libraries linked by default.<BR>
      </TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_MEMSIZE<BR> <FONT color="#999999">No change necessary</FONT></TH>
<TD valign="top" align="left">This specifies the main memory size of NITRO compile targets.<BR>This build switch specification method has been kept for back-compatibility.<BR>We recommend using OS_EnableMainExArena instead, since it does not require rebuilding the SDK. <BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>4M</TD>
<TD>4 Megabytes</TD>
          </TR>
          <TR>
<TD>8M</TD>
<TD>8 Megabytes</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: 4M</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_CCTYPE</TH>
<TD valign="top" align="left">Compiler settings. CW is currently specifiable. <BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>CW</TD>
<TD>CodeWarrior</TD>
          </TR>
          <TR>
<TD>SNC</TD>
<TD>ProDG (scheduled)</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: CW</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_DEBUG<BR> NITRO_RELEASE<BR> NITRO_FINALROM<BR> <FONT color="#ff0000">Important</FONT></TH>
<TD valign="top" align="left">You can select from the following compile targets: DEBUG version, RELEASE version, FINALROM version. When the make command is executed, the compile options and the linked libraries will change according to this setting. Unlike other variables, this variable is enabled by setting an appropriate value to one of the three values. <BR>See $NitroSDK/man/jp_JP/information/compiletarget.html (compile target explanation) for details of these three options.<BR>Initial value: NITRO_RELEASE</TD>
    </TR>
    <TR>
<TH align="left">NITRO_COMPRESS<BR> <FONT color="#ff0000">Important</FONT></TH>
<TD>When some value has been specified, the STATIC/OVERLAY segment is compressed after the link is completed. <BR>Initial value: None (no compression)</TD>
    </TR>
    <TR>
<TH align="left">NITRO_DIGEST</TH>
<TD>This build switch is enabled only for applications. It is disabled when building SDK.<BR>If a value is set, the program will build for a DS download play child program that uses overlays.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_PROFILE</TH>
<TD valign="top" align="left">If a value is set, the -profile option is added when compiling. This is primarily used during debugging so that input and output of each function can be traced during execution. For details of use, see OS_DumpCallTrace().<BR>Initial value: None (-profile option is disabled)</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_NO_OPT_G</TH>
<TD valign="top" align="left">When some value has been set, the -g option used to specify normal compilation and linking is removed. Programmers can expect a reduction in linking times that can become a problem in larger projects.  <BR>Initial value: None (-g option enabled)</TD>
    </TR>
    <TR>
<TH align="left" valign="top">IS_NITRO_DIR</TH>
<TD>This is the directory where IS NITRO EMULATOR related files are installed.<BR>It is automatically configured when IS NITRO EMULATOR is installed.<BR>If this environmental variable exists, the IS NITRO EMULATOR related library is automatically linked. <BR>Initial value: C:/Program Files/INTELLIGENT SYSTEMS/IS-NITRO-EMULATOR</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_ROMSPEED<BR> <FONT color="#ff0000">Important</FONT></TH>
<TD align="left">When the default RSF file is used, the RomSpeedType parameter in the Property section is assigned a value. <BR>The value is the value in the MAKEROM_ROMSPEED symbol that is passed to the makerom.exe tool. <BR>When an original file is used rather than the default RSF file, it is simply ignored. <BR>For details on the RomSpeedType parameter, see the reference for the makerom.exe tool.
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>1TROM</TD>
<TD>One-time PROM</TD>
          </TR>
          <TR>
<TD>MROM</TD>
<TD>Mask ROM</TD>
          </TR>
          <TR>
<TD>UNDEFINED</TD>
<TD>None specified</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: UNDEFINED</TD>
    </TR>
    <TR>
<TH valign="top" align="left">CW_LIBFP</TH>
<TD align="left">You can set one of the following floating-point library names to be specified to the CodeWarrior compiler.<BR>If nothing is specified, the initial value will be used.<BR>For details on the differences in performance between the libraries, see the CodeWarrior reference.
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>FP_fastI_v5t_LE.a</TD>
<TD>fast IEEE</TD>
          </TR>
          <TR>
<TD>FP_fixedI_v5t_LE.a</TD>
<TD>fixed-rounding IEEE</TD>
          </TR>
          <TR>
<TD>FP_fullI_v5t_LE.a</TD>
<TD>full IEEE</TD>
          </TR>
          <TR>
<TD>FP_flush0_v5t_LE.a</TD>
<TD>flush to zero (not IEEE compatible)</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: FP_fastI_v5t_LE.a</TD>
    </TR>
    <TR>
      <TH valign="top" align="left">NITRO_SVC_WAITVBLANK_COMPATIBLE<BR>
      </TH>
      <TD valign="top" align="left">Define this when you do not wish to automatically replace the SVC_WaitVBlankIntr function call with the OS_WaitVBlankIntr function call.<BR> However, the SVC_WaitVBlankIntr function has the specification that will not release the resource to a low-priority thread, so depending upon how this is used some problems may occur. If a system call must be used as it has been in the past, it should be used after thorough verification.<BR><BR> Note that this replacement is made using a define inside a header file, so it will be valid only after the NITRO-SDK is re-built.<BR> If these environmental variables are defined during make, SDK_SVC_WAITVBLANK_COMPATIBLE will be defined and you can find it in the source via #ifdef - #endif statements.<BR><BR>

This is not defined with the initial values, so the SVC_WaitVBlankIntr function call is automatically replaced with the OS_WaitVBlankIntr function call.
</TD>
    </TR>
  </TBODY>
</TABLE>
<H2><A name="MacroInSource">Macro Switches that can be Used in the Source</A></H2>
<P>The below table is a list of the macro variables for finding the NitroSDK tree build conditions from the source by means of #ifdef - #endif directives. Fundamentally, they are controlled by the environment variables mentioned in the previous section.<BR><FONT color="#ff0000">All names start with SDK_.</FONT></P>
<TABLE border="1" width="100%" cellspacing="0" cellpadding="2">
  <COL span="1" width="160">
  <TBODY>
    <TR>
<TH valign="top" align="left">SDK_TS<BR> <S><FONT color="#999999">SDK_TEG<BR> SDK_BB</FONT></S><BR>
      </TH>
<TD align="left" valign="top">One of them is defined in accordance with the NITRO compile target specification (environmental variable NITRO_PLATFORM). Currently, only SDK_TS is supported, so there is no need to be conscious of the settings.<BR>
      <TABLE border="1" width="381">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>SDK_TS</TD>
<TD>Retail version of the Nintendo DS system</TD>
          </TR>
          <TR>
<TD><S>SDK_TEG</S></TD>
<TD><S>Support finish:TEG board</S></TD>
          </TR>
          <TR>
<TD><S>SDK_BB</S></TD>
<TD><S>Support finish:Breadboard</S></TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: SDK_TS</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SDK_4M<BR> <S><FONT color="#999999">SDK_8M</FONT></S></TH>
<TD valign="top" align="left">One of them is defined in accordance with the NITRO compile target main memory size specification (environmental variable NITRO_MEMSIZE). Since the expanded arena can be used, there currently is no need to use the 8M setting. <BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>SDK_4M</TD>
<TD>4 Megabytes</TD>
          </TR>
          <TR>
<TD><S>SDK_8M</S></TD>
<TD><S>8 Megabytes</S></TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: SDK_4M</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SDK_ARM9<BR> <S><FONT color="#999999">SDK_ARM7</FONT></S></TH>
<TD valign="top" align="left">One of these is defined in accordance with the processor for which the compile or assembly is performed. Application developers do not need to pay attention to the SDK_ARM7 code. <BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>SDK_ARM9</TD>
<TD>Build for Main Processor</TD>
          </TR>
          <TR>
<TD><S>SDK_ARM7</S></TD>
<TD><S>Build for Sub Processor</S></TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: SDK_ARM9</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SDK_CODE_ARM<BR> SDK_CODE_THUMB</TH>
<TD valign="top" align="left">Indicates whether the compile option is set to generate Thumb code or ARM code.<BR>This is simply to show &quot;Initial Settings.&quot; You must reference the definition macro that is incorporated in the compiler to see which code is actually being generated. (_thumb_ with CW) We recommend that when pragma has been used to explicitly switch code generation within one range of the source, when this range ends you should return code generation to the setting shown by this value.
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>SDK_CODE_ARM</TD>
<TD>The instructions set for ARM</TD>
          </TR>
          <TR>
<TD>SDK_CODE_THUMB</TD>
<TD>The instructions set for THUMB</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: Follows CODEGEN_CC/CODEGEN_AS settings.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SDK_CW<BR> SDK_SNC<BR>
      </TH>
<TD valign="top" align="left">One of these is defined in accordance with the compiler that is being used. <BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>SDK_CW</TD>
<TD>CodeWarrior</TD>
          </TR>
          <TR>
<TD>SDK_SNC</TD>
<TD>ProDG Compiler (scheduled)</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: SDK_CW</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SDK_ASM</TH>
<TD valign="top" align="left">This is defined when assembled by the assembler.<BR>It can be used when you want write a description that causes an error in the assembler when sharing the C header file.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SDK_DEBUG<BR> SDK_RELEASE<BR> SDK_FINALROM<BR> <FONT color="#ff0000">Important</FONT></TH>
<TD valign="top" align="left">In accordance with the specifications of the DEBUG version, the RELEASE version, or the FINALROM version, one of these is defined as the compile target.<BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>SDK_DEBUG</TD>
<TD>DEBUG version</TD>
          </TR>
          <TR>
<TD>SDK_RELEASE</TD>
<TD>RELEASE version</TD>
          </TR>
          <TR>
<TD>SDK_FINALROM</TD>
<TD>FINALROM version</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: SDK_RELEASE</TD>
    </TR>
    <TR>
<TH align="left" valign="top">SDK_PACKING_DATE<BR> SDK_VERSION_DATE<BR> SDK_VERSION_MAJOR<BR> SDK_VERSION_MINOR<BR> SDK_VERSION_RELSTEP</TH>
<TD valign="top">SDK_PACKING_DATE and SDK_VERSION_DATE indicate the date when the SDK package was created. The date is expressed as an 8-digit number in the YYYYMMDD format. Under current specifications, these two date values are set to the same value.<BR><BR> SDK_VERSION_MAJOR and SDK_VERSION_MINOR represent the version number of the SDK. For example, if the SDK version number is 2.1, SDK_VERSION_MAJOR is set to 2 and SDK_VERSION_MINOR is set to 1. <BR><BR> SDK_VERSION_RELSTEP is used to distinguish between the official SDK release and PR and RC version releases which may be shipped before the official version of the SDK. The value 30000 is used in the official release version.<BR> <BR> These values are defined in the file $NitroSDK/include/nitro/version.h.<FONT color="#ff0000">Unlike in previous versions, version.h is placed in an include statement in nitro.h, beginning with SDK 2.2.</FONT></TD>
    </TR>
    <TR>
      <TH valign="top" align="left">SDK_SVC_WAITVBLANK_COMPATIBLE</TH>
      <TD valign="top" align="left">This is defined if NITRO_SVC_WAITVBLANK_COMPATIBLE is defined during make.<BR> For further details, refer to the section about NITRO_SVC_WAITVBLANK_COMPATIBLE.</TD>
    </TR>
    <TR>
<TH align="left" valign="top">Other</TH>
<TD>Below are other temporary compile switches that have been provided. There are currently no general methods for users to switch these compile switches. Use them as keywords when searching.
      <TABLE border="1">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>SDK_NO_THREAD</TD>
<TD>Creates a library that does not use the THREAD feature.</TD>
          </TR>
          <TR>
<TD>SDK_*BUG_*</TD>
<TD>This switch is for providing measures against bugs.</TD>
          </TR>
          <TR>
<TD>SDK_NO_INTERWORKING</TD>
<TD>Creates a library that does not take switching between Thumb and ARM into considerations.</TD>
          </TR>
          <TR>
<TD>SDK_SMALL_BUILD</TD>
<TD>Creates a library of a reduced code size by limiting some of the functionalities. <BR>(Operation of the library created with this option is not guaranteed.Åj</TD>
          </TR>
        </TBODY>
      </TABLE>
      </TD>
    </TR>
  </TBODY>
</TABLE>
<H2><A name="MacroMisc">Other Macros that can be used in the source</A></H2>
<P>The below table contains the other macros that can be used in the source file.<BR><BR> <FONT color="#ff0000">All names start with SDK_.</FONT></P>
<TABLE border="1" width="100%" cellspacing="0" cellpadding="2">
  <COL span="1" width="160">
  <TBODY>
    <TR>
<TH valign="top" align="left">SDK_WEAK_SYMBOL</TH>
<TD valign="top" align="left">This macro modifies the type name when the function is defined, and shows that the function is a weak symbol. <BR>When CodeWarrior is used as the compiler, this macro is defined as follows:<BR><BR> <CODE>#define SDK_WEAK_SYMBOL __declspec(weak)</CODE><BR> <BR> There is no guarantee that this macro will work with all compilers. If the compiler does not support weak symbols, the macro will be defined as NULL.</TD>
    </TR>
    <TR>
      <TH align="left" valign="top">SDK_INLINE<BR> SDK_DECL_INLINE</TH>
      <TD valign="top">This shows whether a function is configured as a static inline function or an inline function.<BR>The entire NITRO-SDK must be rebuilt if these macro values are changed.<BR> These values are defined in the file $NitroSDK/include/nitro/types.h.<BR><BR>However, the code size can be reduced by changing these macros from static inline to inline only when using the environment with the compiler version in which the the inline function materialization problem has been fixed and using the functions that have been changed from inline to static inline to avoid this problem.<BR> <FONT color="#ff0000">Since the result of changing these macros is essentially not guaranteed, base the decision on the application.</FONT>      <BR><BR>Initial value: SDK_INLINE static inline, SDK_DECL_INLINE static
    </TD>
    </TR>
  </TBODY>
</TABLE>
<H2><A name="MacroInSource">Linker Symbols that can be Used in the Source</A></H2>
<P>The below table shows the values defined in the LCFile (linker script file).<BR>These values are determined during linking.<BR><BR> <FONT color="#ff0000">All names start with SDK_.</FONT></P>
<TABLE border="1" width="100%" cellspacing="0" cellpadding="2">
  <COL span="1" width="160">
  <TBODY>
    <TR>
<TH valign="top" align="left">SDK_SYS_STACKSIZE</TH>
<TD valign="top" align="left">This symbol controls the size of the DTCM stack used during application startup. It is possible to customize for each game by making corrections in the LCF file and the LCF spec file.<BR><BR>The OS_Init() function allocates the DTCM region that can be used (excluding the region reserved by the system and interrupt process) to the stack and DTCM arena based on the stack size determined by this value. The configuration method used by OS_Init() depends on whether the value of SDK_SYS_STACKSIZE is positive, negative, or 0. <BR>
      <TABLE border="1">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>For Positive Values</TD>
<TD>The value of SDK_SYS_STACKSIZE is taken as the stack size and the remaining region is allocated as the DTCM arena.</TD>
          </TR>
          <TR>
<TD>For 0</TD>
<TD>All available DTCM are placed on the stack. <BR>In this case, the DTCM arena cannot be used.</TD>
          </TR>
          <TR>
<TD>For Negative Values</TD>
<TD>The absolute value of SDK_SYS_STACKSIZE is set as the size of the DTCM arena and the remaining region is used as the stack.</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: 0 All available DTCM is used as the stack.</TD>
    </TR>
    <TR>
<TH align="left" valign="top">SDK_IRQ_STACKSIZE</TH>
<TD>This is the stack size that is used in the interrupt routine.<BR>It is secured as a system region in DTCM.<BR>Here we have taken into account function calls in the interrupt routine that use a lot of the stack, such as OS_Printf. Therefore the initial value is a little high. Therefore, this value can be reduced in the shipping version of ROM that does not use OS_Printf.<BR>Depending on the debug environment, you will have to call the debug routine from the interrupt handler, and in some cases you will need to increase this value. For this refer to the documentation for each debug environment.<BR>Initial value: 0x400 bytes</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SDK_MAIN_ARENA_LO</TH>
<TD valign="top">Initial value of the Low address of the main arena.<BR>This value is set automatically during linker.</TD>
    </TR>
  </TBODY>
</TABLE>
<H2><A name="MacroInMakefile">Macro Switches set within the SDK Makefile</A></H2>
<P>The below table is for configuring the build conditions for each directory in the NitroSDK Makefile. Specifies the source locations as well as Makefile to concatenate.</P>
<TABLE border="1" width="100%" cellspacing="0" cellpadding="2">
  <COL span="1" width="160">
  <TBODY>
    <TR>
<TH valign="top" align="left">SUBDIRS<BR> <FONT color="#ff0000">Important</FONT></TH>
<TD align="left" valign="top">Enumerates the directories you want the make process to concatenate. <BR>Initial value: None</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SUBMAKES</TH>
<TD align="left" valign="top">Enumerates the Makefiles you want the make process to concatenate. Initial value: None</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SRCS<BR> <FONT color="#ff0000">Important</FONT></TH>
<TD valign="top" align="left">Enumerates the source file you want to compile and assemble.<BR>make tries to generate an object file by the compiler or assembler of the programming language shown in the following table according to the extension of each file.<BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>Extension</TD>
<TD>Programming Language</TD>
          </TR>
          <TR>
<TD>.c</TD>
<TD>C</TD>
          </TR>
          <TR>
<TD>.cpp</TD>
<TD>C++</TD>
          </TR>
          <TR>
<TD>.s</TD>
<TD>Assembler</TD>
          </TR>
        </TBODY>
      </TABLE>
      </TD>
    </TR>
    <TR>
<TH align="left" valign="top">SRCS_OVERLAY<BR> <FONT color="#0000ff">For Overlay</FONT></TH>
<TD>Enumerates the source file you want to compile or assemble. The object files generated from the files specified here are registered as belonging to an OVERLAY group.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">SRCDIR</TH>
<TD valign="top" align="left">Specifies the source file's directory.<BR>Initial value: ./src <BR>This initial value indicates the directory specified by the relative path src from the directory from which make was executed.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">INCDIR<BR>
      </TH>
<TD valign="top" align="left">Specifies the directory if there are private include files (module-specific include files). If there is no need for this, it does not need to be used.<BR>Initial value: ./include</TD>
    </TR>
    <TR>
<TH valign="top" align="left">OBJDIR<BR> BINDIR<BR> LIBDIR<BR> <FONT color="#0000ff">Rewrite prohibited</FONT></TH>
<TD valign="top" align="left">This is the directory to which temporary files are output by make.<BR>Since this directory may change to accommodate the source tree, avoid overwriting within Makefile in individual directories.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">LCFILE</TH>
<TD valign="top" align="left">Specify this if you want to use your own link command file (.lcf).<BR>Initial value: $NitroSDK/include/nitro/arm9.$(NITRO_PLATFORM).lcf</TD>
    </TR>
    <TR>
<TH align="left" valign="top">LCFILE_SPEC</TH>
<TD>Specify the configuration file to be used as the base when you want to automatically generate a link command file with the makelcf command. Initial value: Not Defined</TD>
    </TR>
    <TR>
<TH align="left" valign="top">ROM_SPEC</TH>
<TD>Specifies the file that describes the contents of the ROM file. This file is passed to the makerom command and becomes a hint for ROM generation.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">TARGET_BIN<BR> <FONT color="#ff0000">Important</FONT></TH>
<TD align="left">Specifies a target file with .srl format or .nef format.<BR>It compiles or assembles the source files specified by SRCS, and links the resulting object files, making them the target files. A.nef file will be created automatically.if a .srl file is specified as the target.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">TARGET_LIB</TH>
<TD align="left">Specify this if you want to create a library file.<BR>It compiles or assembles the source files specified by SRCS, and links the resulting object files, making them a library. Normally, TARGET_BIN and TARGET_LIB are not configured at the same time.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">TARGET_OBJ</TH>
<TD align="left">Specify this if you want to create an object file as a target.<BR>This is not normally used. In the library, this is used when crt0.c is compiled and installed as a library.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">NITRO_PROC<BR> <FONT color="#ff0000">Important for ARM7</FONT></TH>
<TD align="left">This is a switch that switches between generating code for the Main Processor and the Sub Processor. This is often specified in the Makefile.<BR>
      <TABLE border="1" width="350">
        <COL span="1" width="120">
        <TBODY>
          <TR>
<TD>ARM9</TD>
<TD>Code for the Main Processor</TD>
          </TR>
          <TR>
<TD>ARM7</TD>
<TD>Code for the Sub Processor</TD>
          </TR>
        </TBODY>
      </TABLE>
Initial value: ARM9 (Code for the Main Processor)</TD>
    </TR>
    <TR>
<TH valign="top" align="left">TARGETS<BR><FONT color="#0000ff">Rewrite prohibited</FONT></TH>
<TD valign="top" align="left">Targets to which the relative path was added to TARGET_BIN and TARGET_LIB are set up automatically. The storage directories for .srl and .a files changes depending on the NITRO_PLATFORM and NITRO_DEBUG/NITRO_RELEASE/NITRO_FINALROM setting. This macro was prepared to absorb this change.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">INSTALL_TARGETS</TH>
<TD valign="top" align="left">Enumerates the files you want to install. The TARGETS described above will function in this setting. Initial value: None</TD>
    </TR>
    <TR>
<TH valign="top" align="left">INSTALL_DIR</TH>
<TD align="left">Configures the file install destination. Initial value: None</TD>
    </TR>
    <TR>
<TH valign="top" align="left">LINCLUDES</TH>
<TD valign="top" align="left">Specifies the directory if there are other include files.</TD>
    </TR>
    <TR>
<TH valign="top" align="left">LLIBRARY_DIRS<BR> LLIBRARIES</TH>
<TD align="left">If there are other library files, this enumerates their directory with LLIBRARY_DIRS, and the library files with LLIBRARIES.</TD>
    </TR>
    <TR>
<TH align="left" valign="top">LDIRT_CLEAN<BR> LDIRT_CLOBBER</TH>
<TD>Specifies the file you want to delete along with object files and such when executing make clean or make clobber command. With make clean, all files specified with LDIRT_CLEAN are deleted. With make clobber, all files specified with LDIRT_CLEAN and those specified with LDIRT_CLOBBER are deleted.</TD>
    </TR>
  </TBODY>
</TABLE>
CONFIDENTIAL
</BODY>
</HTML>